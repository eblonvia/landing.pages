var installPromiseMatchers;(function(){var t,e,a;installPromiseMatchers=function(){angular.mock.inject(function($injector){t=$injector.get("$rootScope"),e=$injector.get("$httpBackend"),a=$injector.get("$timeout")})};var n={PENDING:"pending",REJECTED:"rejected",RESOLVED:"resolved"},c=function(c,o,s,r,u){var i={};if(c.then(function(t){i.actualData=t,i.actualState=n.RESOLVED},function(t){i.actualData=t,i.actualState=n.REJECTED}),t.$apply(),!i.actualState){try{e.flush()}catch(f){if("No pending request to flush !"!==f.message)throw f}try{a.flush()}catch(f){if("No deferred tasks to be flushed"!==f.message)throw f}}if(i.message="Expected "+i.actualState+" to be "+o,i.pass=i.actualState===o,void 0!==s&&i.pass){i.pass=r?s&&s.asymmetricMatch?r.equals(i.actualData,s,u):angular.equals(i.actualData,s):s instanceof jasmine.Matchers.Any||s instanceof jasmine.Matchers.ObjectContaining?s.jasmineMatches(i.actualData):angular.equals(i.actualData,s);var l="object"==typeof i.actualData?JSON.stringify(i.actualData):i.actualData,E="object"==typeof s?JSON.stringify(s):s;i.message="Expected "+l+" to be "+E}return i},o=function(t){return{message:"Expected "+t+" to be a Promise",pass:t&&t.then instanceof Function}},s={toBePromise:function(){return o(this.actual)},toBeRejected:function(){return c(this.actual,n.REJECTED).pass},toBeRejectedWith:function(t){return c(this.actual,n.REJECTED,t).pass},toBeResolved:function(){return c(this.actual,n.RESOLVED).pass},toBeResolvedWith:function(t){return c(this.actual,n.RESOLVED,t).pass}},r={toBePromise:function(){return{compare:function(t){return o(t)}}},toBeRejected:function(){return{compare:function(t){return c(t,n.REJECTED)}}},toBeRejectedWith:function(t,e){return{compare:function(a,o){return c(a,n.REJECTED,o,t,e)}}},toBeResolved:function(){return{compare:function(t){return c(t,n.RESOLVED)}}},toBeResolvedWith:function(t,e){return{compare:function(a,o){return c(a,n.RESOLVED,o,t,e)}}}},u=/^2/.test(jasmine.version);beforeEach(function(){u?jasmine.addMatchers(r):this.addMatchers(s)})})();